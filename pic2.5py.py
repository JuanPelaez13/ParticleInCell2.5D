# -*- coding: utf-8 -*-
"""PIC_11deOct.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kcz3WsgbYZH7g1Atv3yQOQylzeMy4zgf

## Funciones

### FDTD
"""

def FDTD_halftime(ex,ey,ez,bx,by,bz,dt_tmp):
    for i in range(Nx+1):
        for j in range(1,Ny+1):
            bx[i,j]=bx[i,j]-((dt_tmp/dy)*(ez[i,j]-ez[i,j-1]))
    #Condiciones de frontera Bx: Periodicidad
    for i in range(Nx+1):
        bx[i,0]=bx[i,Ny]

    for i in range(1,Nx+1):
        for i in range(Ny+1):
            by[i,j]=by[i,j]+((dt_tmp/dx)*((ez[i,j]-ez[i-1,j])))
    #Condiciones de frontera By: Periodicidad
    for j in range(Ny+1):
        by[0,j]=by[Nx,j]

    for i in range(Nx):
        for j in range(Ny):
            bz[i,j]= bz[i,j] + ( ((dt_tmp/dy)*((ex[i,j+1]-ex[i,j]))) - ((dt_tmp/dx)*(ey[i+1,j]-ey[i,j])) )
    #Condiciones de frontera Bz: Periodicidad
    #Esquina
    bz[Nx,0]=bz[0,0]
    for i in range(Nx+1):
        bz[i,Ny]=bz[i,0]
    for j in range(Ny+1):
        bz[Nx,j]=bz[0,j]

    return bx,by,bz



def FDTD(ex,ey,ez,bx,by,bz,ex_copy,ey_copy,ez_copy,bx_copy,by_copy,bz_copy):

    #Evolución del campo BX,BY Y BZ ----> dt
    #Evolución de Bx,By,Bz ---> dt

    for i in range(Nx+1):
      for j in range(1,Ny+1):
        ex_copy[i,j],ey_copy[i,j],ez_copy[i,j]=ex[i,j],ey[i,j],ez[i,j]
        bx_copy[i,j],by_copy[i,j],bz_copy[i,j]=bx[i,j],by[i,j],bz[i,j]


    for i in range(Nx+1):
        for j in range(1,Ny+1):
            bx[i,j]=bx[i,j] - ((dt/dy)*(ez[i,j]-ez[i,j-1]))
    #Condiciones de frontera Bx: Periodicidad
    for i in range(Nx+1):
        bx[i,0]=bx[i,Ny]

    for i in range(1,Nx+1):
        for j in range(Ny+1):
            by[i,j]=by[i,j] + ((dt/dx)*((ez[i,j]-ez[i-1,j])))
    #Condiciones de frontera By: Periodicidad
    for j in range(Ny+1):
        by[0,j]=by[Nx,j]

    for i in range(Nx):
        for j in range(Ny):
            bz[i,j]= bz[i,j] + ( ((dt/dy)*((ex[i,j+1]-ex[i,j]))) - ((dt/dx)*(ey[i+1,j]-ey[i,j])) )
    #Condiciones de frontera Bz: Periodicidad
    #Esquina
    bz[Nx,0]=bz[0,0]
    for i in range(Nx+1):
        bz[i,Ny]=bz[i,0]
    for j in range(Ny+1):
        bz[Nx,j]=bz[0,j]

    #Evolución de Ex,Ey,Ez ------> dt

    for i in range(Nx+1):
        for j in range(1,Ny+1):
            ex[i,j]= ex[i,j] + ((dt/dy)*(bz[i,j]-bz[i,j-1])) #- 4*pi *jx[i,j]
    #Condiciones de frontera Bx: Periodicidad
    for i in range(Nx+1):
        ex[i,0]=ex[i,Ny]

    for i in range(1,Nx+1):
        for j in range(Ny+1):
            ey[i,j]= ey[i,j] - ((dt/dx)*((bz[i,j]-bz[i-1,j]))) #- 4*pi *jy[i,j]
    #Condiciones de frontera By: Periodicidad
    for j in range(Ny+1):
        ey[0,j]=ey[Nx,j]

    for i in range(Nx):
        for j in range(Ny):
            ez[i,j]=ez[i,j] - ( ((dt/dy)*((bx[i,j+1]-bx[i,j]))) - ((dt/dx)*(by[i+1,j]-by[i,j])) ) #- 4*pi *jz[i,j]
    #Condiciones de frontera Bz: Periodicidad
    #Esquina
    ez[Nx,0]=ez[0,0]
    for i in range(Nx+1):
        ez[i,Ny]=ez[i,0]
    for j in range(Ny+1):
        ez[Nx,j]=ez[0,j]

    for i in range(Nx+1):
        for j in range(Ny+1):
          bx_copy[i,j]=0.5*(bx_copy[i,j]+bx[i,j])
          by_copy[i,j]=0.5*(by_copy[i,j]+by[i,j])
          bz_copy[i,j]=0.5*(bz_copy[i,j]+bz[i,j])

    return ex,ey,ez,bx,by,bz,ex_copy,ey_copy,ez_copy,bx_copy,by_copy,bz_copy


#lleva los valores de los campos en los nodes(nx_1,ny+1) a los centros  (nx,ny)
def nodes_to_c(xgc_ex,xgc_ey,xgc_ez,xgc_bx,xgc_by,xgc_bz,bx,by,ex,ey,bz,ez):
  for i in range(Nx):
    for j in range(Ny):
      xcg_bx=0.25*(bx[i,j]+bx[i+1,j]+bx[i,i+1]+bx[i+1,j+1])
      xcg_ex=0.25*(ex[i,j]+ex[i+1,j]+ex[i,i+1]+ex[i+1,j+1])
      xcg_ey=0.25*(ey[i,j]+ey[i+1,j]+ey[i,i+1]+ey[i+1,j+1])
      xcg_by=0.25*(by[i,j]+by[i+1,j]+by[i,i+1]+by[i+1,j+1])
      xcg_bx=0.25*(bx[i,j]+bx[i+1,j]+bx[i,i+1]+bx[i+1,j+1])
      xcg_ez=0.25*(ez[i,j]+ez[i+1,j]+ez[i,i+1]+ez[i+1,j+1])
      xcg_bz=bz[i,j]


#Lleva los valores de los campos en los centros (nx,ny) a los nodes nodos
def c_to_nodes(xcg_ex, xcg_ey, xcg_ez, xcg_bx,xcg_by,xcg_bz,bx,by,ex,ey,bz,ez):
  for i in range(1,Nx):
    for j in range(1,Ny):
      ex[i,j]=0.25*(xgc_ex[i-1,j-1]+xgc_ex[i,j-1]+xgc_ex[i-1,j]+xgc_ex[i,j])
      bx[i,j]=0.25*(xgc_bx[i-1,j-1]+xgc_bx[i,j-1]+xgc_bx[i-1,j]+xgc_bx[i,j])
      by[i,j]=0.25*(xgc_by[i-1,j-1]+xgc_by[i,j-1]+xgc_by[i-1,j]+xgc_by[i,j])
      ey[i,j]=0.25*(xgc_ey[i-1,j-1]+xgc_ey[i,j-1]+xgc_ey[i-1,j]+xgc_ey[i,j])
      ez[i,j]=0.25*(xgc_ez[i-1,j-1]+xgc_ez[i,j-1]+xgc_ez[i-1,j]+xgc_ez[i,j])

  #for Ez 2D setup
  for i in range(1,Nx):
    for j in range(1,Ny):
      bz[i,j]=xgc_bz[i-1,j-1]


#Condiciones de frontera preguntar
#
#     for(int iy=1;iy<Ny;iy++)
#     {
#             field[0][iy][0].ex = 0.25*(xgc[0][iy-1][0].ex + xgc[0][iy][0].ex + xgc[Nx-1][iy][0].ex + xgc[Nx-1][iy-1][0].ex);
#             field[0][iy][0].bx = 0.25*(xgc[0][iy-1][0].bx + xgc[0][iy][0].bx + xgc[Nx-1][iy][0].bx + xgc[Nx-1][iy-1][0].bx);

#             field[0][iy][0].ey = 0.25*(xgc[0][iy-1][0].ey + xgc[0][iy][0].ey + xgc[Nx-1][iy][0].ey + xgc[Nx-1][iy-1][0].ey);
#             field[0][iy][0].by = 0.25*(xgc[0][iy-1][0].by + xgc[0][iy][0].by + xgc[Nx-1][iy][0].by + xgc[Nx-1][iy-1][0].by);

#             field[0][iy][0].ez = 0.25*(xgc[0][iy-1][0].ez + xgc[0][iy][0].ez + xgc[Nx-1][iy][0].ez + xgc[Nx-1][iy-1][0].ez);

#     }

#     for(int ix=1;ix<Nx;ix++)
#     {
#         field[ix][0][0].ex = 0.25*(xgc[ix][0][0].ex + xgc[ix-1][0][0].ex + xgc[ix][Ny-1][0].ex + xgc[ix-1][Ny-1][0].ex);

#         field[ix][0][0].bx = 0.25*(xgc[ix][0][0].bx + xgc[ix-1][0][0].bx + xgc[ix][Ny-1][0].bx + xgc[ix-1][Ny-1][0].bx);

#         field[ix][0][0].ey = 0.25*(xgc[ix][0][0].ey + xgc[ix-1][0][0].ey + xgc[ix][Ny-1][0].ey + xgc[ix-1][Ny-1][0].ey);

#         field[ix][0][0].by = 0.25*(xgc[ix][0][0].by + xgc[ix-1][0][0].by + xgc[ix][Ny-1][0].by + xgc[ix-1][Ny-1][0].by);

#         field[ix][0][0].ez = 0.25*(xgc[ix][0][0].ez + xgc[ix-1][0][0].ez + xgc[ix][Ny-1][0].ez + xgc[ix-1][Ny-1][0].ez);
#     }

#     //corners
#     field[0][0][0].ex = 0.25*(xgc[0][0][0].ex + xgc[0][Ny-1][0].ex + xgc[Nx-1][0][0].ex + xgc[Nx-1][Ny-1][0].ex);

#     field[0][0][0].bx = 0.25*(xgc[0][0][0].bx + xgc[0][Ny-1][0].bx + xgc[Nx-1][0][0].bx + xgc[Nx-1][Ny-1][0].bx);

#     field[0][0][0].ey = 0.25*(xgc[0][0][0].ey + xgc[0][Ny-1][0].ey + xgc[Nx-1][0][0].ey + xgc[Nx-1][Ny-1][0].ey);

#     field[0][0][0].by = 0.25*(xgc[0][0][0].by + xgc[0][Ny-1][0].by + xgc[Nx-1][0][0].by + xgc[Nx-1][Ny-1][0].by);

#     field[0][0][0].ez = 0.25*(xgc[0][0][0].ez + xgc[0][Ny-1][0].ez + xgc[Nx-1][0][0].ez + xgc[Nx-1][Ny-1][0].ez);


  for i in range(Nx):
    ex[i,Ny]=ex[i,0]
    bx[i,Ny]=bx[i,0]
    ey[i,Ny]=ey[i,0]
    by[i,Ny]=by[i,0]
    ez[i,Ny]=ez[i,0]

  for j in range(Ny):
    ex[Nx,j]=ex[0,j]
    bx[Nx,j]=bx[0,j]
    ey[Nx,j]=ey[0,j]
    by[Nx,j]=by[0,j]
    ez[Nx,j]=ez[0,j]

  for i in range(Nx+1):
    bz[i,0]=bz[i,Ny]

  for j in range(Ny+1):
    bz[0,j]=bz[Nx,j]

  #Esquina
  bz[0,0]=bz[Nx,Ny]


  for i in range(Nx):
    for j in range(Ny):
      bx_copy[i,j]=bx[i,j]
      by_copy[i,j]=by[i,j]
      bz_copy[i,j]=bz[i,j]
      ex_copy[i,j]=ex[i,j]
      by_copy[i,j]=ey[i,j]
      ez_copy[i,j]=ez[i,j]


def nodes_to_inter(ICx,ICy,bx_copy,by_copy,bz_copy,ex_copy,ey_copy,ez_copy,ex,ey,ez,bx,by,bz):
  for i in range(Nx):
    for j in range(Ny):
      bx_copy[i,j]=bx[i,j]
      by_copy[i,j]=by[i,j]
      bz_copy[i,j]=bz[i,j]
      ex_copy[i,j]=ex[i,j]
      by_copy[i,j]=ey[i,j]
      ez_copy[i,j]=ez[i,j]

  for i in range(Nx+1):
    for j in range(Ny+1):
      ey_copy[i,j]=0.5*(ey[i,j]+ey[i-1,j])
      by_copy[i,j]=0.5*(by[i,j]+by[i-1,j])
      ICx[i,j]=0.5*(ICx[i,j]+ICx[i,j-1])

  #Condiciones de frontera

  for j in range(Ny+1):
    ey[0,j]=ey[Nx,0]
    by[0,j]=by[Nx,0]
    ICy[0,j]=ICy[Nx,0]

    for i in range(Nx+1):
      for j in range(Ny+1):
        ex_copy[i,j]=0.5*(ex[i,j]+ex[i-1,j])
        bx_copy[i,j]=0.5*(bx[i,j]+bx[i-1,j])
        ICy[i,j]=0.5*(ICy[i,j]+ICy[i,j-1])

    for i in range(Nx+1):
      ex[i,0]=ey[i,Ny]
      bx[i,0]=by[i,Ny]
      ICx[i,0]=ICx[i,Ny]

def interc_to_nodes(ex_copy,ey_copy,ez_copy, bx_copy,by_copy,bz_copy, ex_nodes, ey_nodes, ez_nodes, bx_nodes, by_nodes, bz_nodes):

  for i in range(Nx+1):
    for j in range(Ny):
      ex_nodes[i,j]=0.5*(ex_copy[i,j]+ex_copy[i,j+1])
      bx_nodes[i,j]=0.5*(bx_copy[i,j]+bx_copy[i,j+1])

  for i in range(Nx+1):
    ex_nodes[i,0]=ex_copy[i,Ny]
    bx_nodes[i,0]=bx_copy[i,Ny]

  for i in range(Nx):
    for j in range(Ny+1):
      ey_nodes[i,j]=0.5*(ey_copy[i,j]+ey_copy[i+1,j])
      by_nodes[i,j]=0.5*(by_copy[i,j]+by_copy[i+1,j])

  for j in range(Ny+1):
    ey_nodes[0,j]=ex_copy[Nx,j]
    by_nodes[0,j]=bx_copy[Nx,j]

  ez_nodes, bz_nodes =  ez_copy,bz_copy

  return ex_nodes, ey_nodes, ez_nodes, bx_nodes, by_nodes, bz_nodes

def divBt(bx_tmp,by_tmp,bz_tmp,divB):
  divB = np.zeros([Nx+1,Ny+1])
  for ii in range(1,Nx+1):
    for jj in range(1,Ny+1):
      #print(i,j)
      divB[ii,jj] = (bx_tmp[ii,jj] - bx_tmp[ii-1,jj]) + (by_tmp[ii,jj] - by_tmp[ii,jj-1])

  print(np.sqrt(np.mean(divB**2)))

  return divB

"""### PIC functions"""

def velocity(x_act,v_act,ex,ey,ez,bx,by,bz,dt_tmp):
    for j in range(Np):
        # Renombro posición y velocidades
        x0, y0, z0 = x_act[j, 0], x_act[j, 1], x_act[j, 2]
        ux0, uy0, uz0 = v_act[j, 0], v_act[j, 1], v_act[j, 2]
        # Interpolación: found the closest node indexes according to particle position
        ileft, iright, hxleft, jdown, jup, hydown = interpolation(x0, y0, Xmin, Ymin, dx, dy, xx, yy)
        # Obtener campos tiempo n
        Ex, Ey, Ez, Bx, By, Bz = get_fields_nodes(ex, ey, ez, bx, by, bz, ileft, iright, hxleft, jdown, jup, hydown)
        # BorisA
        v_new[j, 0],v_new[j, 1],v_new[j, 2] = BorisA(Ex, Ey, Ez, Bx, By, Bz, ux0, uy0, uz0, q, m, dt_tmp)
    return v_new


def position(x_act,v_new, x_new, x_BC):
    for j in range(Np):
        x0, y0, z0 = x_act[j, 0], x_act[j, 1], x_act[j, 2]
        u_finalx, u_finaly, u_finalz = v_new[j, 0], v_new[j, 1], v_new[j, 2]
        x1, xBC1, x2, xBC2 , x3, xBC3 = leapfrog(x0, y0, z0, u_finalx, u_finaly, u_finalz)
        x_new[j, 0] = x1
        x_new[j, 1] = x2
        x_new[j, 2] = x3
        x_BC[j, 0] = xBC1
        x_BC[j, 1] = xBC2
        x_BC[j, 2] = xBC3

    return x_new,x_BC


def energy(v_new):
    energia_cinetica = 0
    for j in range(Np):
        # Energía
        energia_cinetica = energia_cinetica + 0.5*m*(v_new[j,0]**2+v_new[j,1]**2+v_new[j,2]**2)
        #epsilon_r[i] = (energia_cinetica[i] - energia_cinetica[0])/energia_cinetica[0]
    energia_cinetica = energia_cinetica/Np
    return energia_cinetica




def interpolation(posx, posy, xmin, ymin, dx, dy,xx, yy):
    ix = int((posx-xmin)/dx)  # index x
    xleft = posx  # position of the left node
    xright = xleft+dx  # position of the right node
    ileft = ix  # index of the left node
    iright = ix+1  # #index of the right node
    # particle fractional x-distance from the nearest node
    hxleft = (posx-xx[ix])/dx
    # y-direction
    jy = int((posy-ymin)/dy)  # index y
    ydown = posy  # position of the down node
    yup = ydown+dy  # position of the up node
    jdown = jy  # index of the down node
    jup = jy+1  # index of up node
    # particle fractional y-distance from the nearest node
    hydown = (posy-yy[jy])/dy
    # print(ileft,iright,hxleft,jdown,jup,hydown)
    return ileft, iright, hxleft, jdown, jup, hydown


def get_fields_nodes(ex, ey, ez, bx, by, bz, ileft, iright, hxleft, jdown, jup, hydown):
    # weight functions
    w1 = (1.0-hxleft)*(1.0-hydown)
    w2 = hxleft*(1.0-hydown)
    w3 = (1.0-hxleft)*hydown
    w4 = hxleft*hydown
    # linear interpolations of fields on the particle position
    Ex = w1*ex[ileft, jdown] + w2*ex[iright, jdown] + w3*ex[ileft, jup] + w4*ex[iright, jup]
    Ey = w1*ey[ileft, jdown] + w2*ey[iright, jdown] + w3*ey[ileft, jup] + w4*ey[iright, jup]
    Ez = w1*ez[ileft, jdown] + w2*ez[iright, jdown] + w3*ez[ileft, jup] + w4*ez[iright, jup]
    Bx = w1*bx[ileft, jdown] + w2*bx[iright, jdown] + w3*bx[ileft, jup] + w4*bx[iright, jup]
    By = w1*by[ileft, jdown] + w2*by[iright, jdown] + w3*by[ileft, jup] + w4*by[iright, jup]
    Bz = w1*bz[ileft, jdown] + w2*bz[iright, jdown] + w3*bz[ileft, jup] + w4*bz[iright, jup]
    return Ex, Ey, Ez, Bx, By, Bz


def BorisA(Ex, Ey, Ez, Bx, By, Bz, velx, vely, velz, q, m, dt):
    # Hallar la velocidad final
    # paso 1 ecuacion (3) del documento (Inicicializar velocidades)
    ux0 = velx
    uy0 = vely
    uz0 = velz
    # Velocidad un más adelante "(Ex*q/(2.0*m))""
    u_menosx = ux0 + (Ex*q/(2.0*m))
    u_menosy = uy0 + (Ey*q/(2.0*m))
    u_menosz = uz0 + (Ez*q/(2.0*m))
    # Ángulo de fase de la rotación
    # Paso 2 ecuacion (6) del documento
    tx = q*dt*Bx/(2.0*m)
    ty = q*dt*By/(2.0*m)
    tz = q*dt*Bz/(2.0*m)
    # paso 3 ecuacion (8) del documento.
    u_primax = u_menosx + ((u_menosy*tz)-(u_menosz*ty))
    u_primay = u_menosy + ((u_menosz*tx)-(u_menosx*tz))
    u_primaz = u_menosz + ((u_menosx*ty)-(u_menosy*tx))
    # Agrupando terminos:
    sx = 2*tx/(1.0+(tx*tx))
    sy = 2*ty/(1.0+(ty*ty))
    sz = 2*tz/(1.0+(tz*tz))
    # Paso 4 ecuacion(9)
    u_masx = u_menosx + ((u_primay*sz) - (u_primaz*sy))
    u_masy = u_menosy + ((u_primaz*sx) - (u_primax*sz))
    u_masz = u_menosz + ((u_primax*sy) - (u_primay*sx))
    # Paso 5
    u_finalx = u_masx + (Ex*q/(2*m))
    u_finaly = u_masy + (Ey*q/(2*m))
    u_finalz = u_masz + (Ez*q/(2*m))
    return u_finalx, u_finaly, u_finalz


def leapfrog(posx, posy, posz, ux, uy, uz):
    # Movimiento en x
    x_new = posx+ux*dt
    # Movimiento en y
    y_new = posy+uy*dt
    # Movimiento en z
    z_new = posz+uz*dt
    # Prueba para ver distancia excedida por dx o dy
    # if abs(x_new-posx)>dx:
    #   print(x_new-posx, 'cruzó más de una celda')
    # if abs(y_new-posy)>dy:
    #   print(y_new-posy, 'cruzó más de una celda')
    # Condiciones de frontera en x
    if x_new>Xmax:
        x_BC = x_new-Lx # x_BC: posición nueva con Boundary Condition
    elif x_new<Xmin:
        x_BC = x_new+Lx # x_BC: posición nueva con Boundary Condition
    else:
        x_BC = x_new

    # Condiciones de frontera en y
    if y_new>Ymax:
        y_BC = y_new-Ly # y_BC: posición nueva con Boundary Condition
    elif y_new<Ymin:
        y_BC = y_new+Ly # y_BC: posición nueva con Boundary Condition
    else:
        y_BC = y_new

    z_BC = z_new

    return x_new, x_BC, y_new, y_BC, z_new, z_BC



def zig_zag(x_act,x_new,x_bc,ICx,ICy,peso_particula):
  for i in range(Np):
    x1, y1, z1 = x_act[i, 0], x_act[i, 1], x_act[i, 2]
    x2, y2, z2 = x_new[i, 0], x_new[i, 1], x_new[i, 2]
    x_BC, y_BC, z_BC = x_bc[i, 0], x_bc[i, 1], x_bc[i, 2]

    ii0=int(math.floor((x1-Xmin)/dx))
    jj0=int(math.floor((y1-Ymin)/dy))
    ii1=int(math.floor((x2-Xmin)/dx))
    jj1=int(math.floor((y2-Ymin)/dy))
    ii2=int(math.floor((x_BC-Xmin)/dx))
    jj2=int(math.floor((y_BC-Ymin)/dy))


    if(ii0==ii1):
      xr= 0.5*(x1+x2);
    else:
      xr= 0.5*((ii0+ii1)*dx);

    if(jj0==jj1):
      yr= 0.5*(y1+y2);
    else:
      yr= 0.5*((jj0+jj1)*dy);

    Fx1 = q*(xr-x1)/dt
    Fy1 = q*(yr-y1)/dt
    Fx2 = q*(x2-xr)/dt
    Fy2 = q*(y2-yr)/dt

    Wx1 = ((x1+xr)/2*dx) - ii0
    Wy1 = ((y1+yr)/2*dy) - jj0
    Wx2 = ((xr+x2)/2*dx) - ii1
    Wy2 = ((yr+y2)/2*dx) - jj1

    c = 1/(dx*dy)

    J1xU = c*Fx1*(1-Wy1)  # Jx(ii0+1/2, jj0)
    J1xD = c*Fx1*(Wy1)  # Jx(ii0+1/2, jj0+1)
    J1yL = c*Fy1*(1-Wx1)  # Jy(ii0, jj0+1/2)
    J1yR = c*Fy1*(Wx1)  # Jy(ii0+1, jj0+1/2)

    J2xU = c*Fx2*(1-Wy2)  # Jx(ii1+1/2, J2)
    J2xD = c*Fx2*(Wy2)  # Jx(ii1+1/2, J2+1)
    J2yL = c*Fy2*(1-Wx2)  # Jy(ii1, J2+1/2)
    J2yR = c*Fy2*(Wx2)  # Jy(ii1+1, J2+1/2)

    # Indices para interceldas que aporta la posición INICIAL

    ileft1=ii0
    iright1=ileft1+1
    jdown1=jj0
    jup1=jdown1+1

      # Llenar densidad de corriente en las interceldas (posición inicial)
    ICx[iright1][jdown1] = ICx[iright1][jdown1] + J1xU*peso_particula
    ICx[iright1][jup1]   = ICx[iright1][jup1]   + J1xD*peso_particula
    ICy[ileft1][jup1]    = ICy[ileft1][jup1]    + J1yL*peso_particula
    ICy[iright1][jup1]   = ICy[iright1][jup1]   + J1yR*peso_particula

    # Casos para los cuales la partícula se sale de la caja
    ileft2=ii2
    iright2=ileft2+1
    jdown2=jj2
    jup2=jdown2+1

    # Llenar densidad de corriente en las interceldas (posición final)
    ICx[iright2][jdown2] = ICx[iright2][jdown2] + J2xU*peso_particula
    ICx[iright2][jup2]   = ICx[iright2][jup2]   + J2xD*peso_particula
    ICy[ileft2][jup2]    = ICy[ileft2][jup2]    + J2yL*peso_particula
    ICy[iright2][jup2]   = ICy[iright2][jup2]   + J2yR*peso_particula



  for j in range(Ny):
    ICx[0,j] = ICx[Nx,j]
  for i in range(Nx):
    ICx[i,0]=ICx[i,Ny]+ICx[i,0]
    ICx[i,0]=ICx[i,Ny]

  for i in range(Nx):
    ICy[i,0] = ICy[i,Ny]
  for j in range(Ny):
    ICy[0,j]=ICy[Nx,j]+ICy[0,j]
    ICy[0,j]=ICy[Nx,j]

  return ICx, ICy

"""### Output: Archivos"""

def output_particle(x_act,v_act,i):
    file_name = 'particle'+str(i)+'.pkl'
    # Guardar posición y velocidades en pickle
    df_tmp = pd.DataFrame({'x':x_act[:, 0], 'y':x_act[:, 1], 'z':x_act[:, 2],
                           'vx':v_act[:, 0],'vy':v_act[:, 1],'vz':v_act[:, 2]})
    df_tmp.to_pickle(file_name) # convierte a .pickel
    return

def output_fields(exp,eyp,ezp,bxp,byp,bzp,jxp,jyp,jzp,i,divBp, header = 'fields'):

    file_name = header+str(i)+'.pkl'
    ex_t = np.reshape(exp,[1, (Nx+1)*(Ny+1)])
    ey_t = np.reshape(eyp,[1, (Nx+1)*(Ny+1)])
    ez_t = np.reshape(ezp,[1, (Nx+1)*(Ny+1)])
    bx_t = np.reshape(bxp,[1, (Nx+1)*(Ny+1)])
    by_t = np.reshape(byp,[1, (Nx+1)*(Ny+1)])
    bz_t = np.reshape(bzp,[1, (Nx+1)*(Ny+1)])
    jx_t = np.reshape(jxp,[1, (Nx+1)*(Ny+1)])
    jy_t = np.reshape(jyp,[1, (Nx+1)*(Ny+1)])
    jz_t = np.reshape(jzp,[1, (Nx+1)*(Ny+1)])
    divB_t=np.reshape(divBp,[1, (Nx+1)*(Ny+1)])

    # Guardar posición y velocidades en pickle
    df_tmp = pd.DataFrame({'ex': ex_t[0,:], 'ey':ey_t[0,:], 'ez':ez_t[0,:],
                           'bx': bx_t[0,:], 'by':by_t[0,:], 'bz':bz_t[0,:],
                           'jx': jx_t[0,:], 'jy':jy_t[0,:], 'jz':jz_t[0,:],
                           'DivB':divB_t[0,:]})
    df_tmp.to_pickle(file_name)
    return

# df = np.arange(10)
# df = pd.DataFrame(df)
# df.to_pickle('alejo.txt')

# # Dataframe

# a = np.zeros([10, 10])
# dataframe = pd.DataFrame(a)
# dataframe
# dataframe.to_csv('juan.csv')

"""Normalización de Variables

## Ciclo principal
"""

import math
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from numpy import random
import pandas as pd
import random
import sys

Xmin = 0
Xmax =  200
Ymin = 0
Ymax =  200
Nx = 200
Ny = 200
dt = 0.5
n_iteraciones = int(120)
n_out = 5 #int(0.5/dt) # Esto es cada dos iteraciones hace outputs
n_check = 5 # Cada cuanto se guarda informacion
Npart_cell = 1 # Número inicial de partículas en cada celda
Np = Npart_cell*Nx*Ny # Asumiendo que en cada celda hay una SP
q = 1.0
m = 1.0
dim = 3
# Para la distribución gaussiana, qué poner para que quede solamente la vth
mu = 1
sigma = 1
Vth = mu
Lx = Xmax-Xmin
Ly = Ymax-Ymin
dx = Lx/Nx
dy = Ly/Ny
t_final = n_iteraciones
partweight = 1/Npart_cell

# crear malla
xx = np.linspace(Xmin, Xmax, Nx+1)
yy = np.linspace(Ymin, Ymax, Ny+1)
malla_x, malla_y = np.meshgrid(xx, yy)

energia_cinetica = np.zeros(n_iteraciones)
epsilon_r = np.zeros(n_iteraciones)



# posiciones antiguas, actuales y nuevas de cada partícula (# 1000 Arrays con 2 posiciones(x,y))
x_BC = np.zeros([Np, dim])
x_act = np.zeros([Np, dim]) #act: actual (esta se usa para las condiciones iniciales)
v_act = np.zeros([Np, dim])
v_0 = np.zeros([Np, dim])
x_new = np.zeros([Np, dim]) #new: nueva
v_new = np.zeros([Np, dim])

# campo electromagnetico (B & E on the nodes)
bx = np.zeros([Nx+1, Ny+1])
by = np.zeros([Nx+1, Ny+1])
bz = np.zeros([Nx+1, Ny+1])
ex = np.zeros([Nx+1, Ny+1])
ey = np.zeros([Nx+1, Ny+1])
ez = np.zeros([Nx+1, Ny+1])
jx = np.zeros([Nx+1, Ny+1])
jy = np.zeros([Nx+1, Ny+1])
jz = np.zeros([Nx+1, Ny+1])
divB=np.zeros([Nx+1, Ny+1])

# Trabajo juan
bx_copy = np.zeros([Nx+1, Ny+1])
by_copy = np.zeros([Nx+1, Ny+1])
bz_copy = np.zeros([Nx+1, Ny+1])
ex_copy = np.zeros([Nx+1, Ny+1])
ey_copy = np.zeros([Nx+1, Ny+1])
ez_copy = np.zeros([Nx+1, Ny+1])

bx_tmp = np.zeros([Nx+1, Ny+1])
by_tmp = np.zeros([Nx+1, Ny+1])
bz_tmp = np.zeros([Nx+1, Ny+1])
ex_tmp = np.zeros([Nx+1, Ny+1])
ey_tmp = np.zeros([Nx+1, Ny+1])
ez_tmp = np.zeros([Nx+1, Ny+1])

# trabajo juan
xgc_bx=np.zeros([Nx,Ny])
xgc_ex=np.zeros([Nx,Ny])
xgc_ey=np.zeros([Nx,Ny])
xgc_by=np.zeros([Nx,Ny])
xgc_ez=np.zeros([Nx,Ny])
xgc_bz=np.zeros([Nx,Ny])

for i in range(Np):
  x_act[i, 0] = random.uniform(Xmin, Xmax) # Genera un número pseudoaleatorio entre Xmin y Xmax
  x_act[i, 1] = random.uniform(Xmin, Xmax) # Genera un número pseudoaleatorio entre Xmin y Xmax
  x_act[i, 2] = random.uniform(Xmin, Xmax) # Genera un número pseudoaleatorio entre Xmin y Xmax
  v_act[i, 0] = random.gauss(mu, sigma) # Es esto o crear una función gaussian(vth)
  v_act[i, 1] = random.gauss(mu, sigma) # Es esto o crear una función gaussian(vth)
  v_act[i, 2] = random.gauss(mu, sigma) # Es esto o crear una función gaussian(vth)

# Definicion de los campos uniformes
for j in range(0,Ny+1):
  for i in range(0,Nx+1):
    ex[i,j] = 0
    bz[i,j] = 0



# Ciclo principal con campos uniformes
t0 = 20
spread = 6
df_energy=open('energy.txt','w')


#output initial particle distribution and EM fields
# v_new = v_act.copy()
v_new[:,0],v_new[:,1],v_new[:,2] = v_act[:,0],v_act[:,1],v_act[:,2]
output_particle(x_act,v_act,i)
output_fields(ex,ey,ez,bx,by,bz,jx,jy,jz,i,divB)
v_act = velocity(x_act,v_new,ex,ey,ez,bx,by,bz,-0.5*dt)
bx,by,bz = FDTD_halftime(ex,ey,ez,bx,by,bz,-0.5*dt)

for i in range(n_iteraciones):  # ciclo principal

    #PRUEBAS FDTD

    # Atmp = np.exp(-0.5*((t0-i)/spread)**2)  # Pulso Gaussiano
    # ez[int(Nx/2),int(Ny/2)] = Atmp # Pulso Gaussiano

    #ex[int(Nx/2),int(Ny/2)]=np.exp(-i**2/20) #Superluminal waves from a source that turns on immediately.

    ez[int(Nx/2),int(Ny/2)]=np.sin(i/5)

    if(i % n_check == 0): # Cada n_check iteraciones guarda energias
        print('se guarda energias en iteracion', i)
        energia_cinetica = energy(v_act)
        df_energy.write(str(i))
        df_energy.write('\t')
        df_energy.write(str(energia_cinetica))
        df_energy.write('\n')

    print(i)
    divB=divBt(bx,by,bz,divB)
    #guardar energia cinetica promedio del ensamble de part
    #advance E, B. E advance like: E^{n} to E^{n+1}, and B advance like: B^{n-1/2} to B^{n+1/2}
    ex,ey,ez,bx,by,bz, ex_copy, ey_copy, ez_copy, bx_copy, by_copy, bz_copy = FDTD(ex, ey, ez, bx, by, bz, ex_copy, ey_copy, ez_copy, bx_copy, by_copy, bz_copy) #convierte los campos de la malla a DF
    #advance velocity v^{n-1/2} to v^{n+1/2}, o sea, un paso temporal
    ex_copy, ey_copy, ez_copy, bx_copy, by_copy, bz_copy = interc_to_nodes(ex, ey, ez, bx, by, bz, ex_copy, ey_copy, ez_copy, bx_copy, by_copy, bz_copy)
    v_new = velocity(x_act,v_act,ex_copy, ey_copy, ez_copy, bx_copy, by_copy, bz_copy, dt)
    #advance position x^{n} to x^{n+1}, o sea, un paso temporal
    x_new, x_BC = position(x_act,v_new,x_new,x_BC) # leapfrog
    # Densidad de corriente
    jx = np.zeros([Nx+1, Ny+1])
    jy = np.zeros([Nx+1, Ny+1])
    jx, jy = zig_zag(x_act,x_new,x_BC,jx,jy,partweight)
    #asignar antes de empezar el nuevo ciclo
    # print((x_act.size), (x_BC.size), sep = '/')
    x_act[:,0],x_act[:,1],x_act[:,2] = x_BC[:,0],x_BC[:,1],x_BC[:,2]
    v_act[:,0],v_act[:,1],v_act[:,2] = v_new[:,0],v_new[:,1],v_new[:,2]

    # Carlos
    # if(i%n_out == 0): #Cada n_out iterations se guardan particle y campos
    #   #atrasa la velocidad para guardarla (la devuleve hasta tiempo {n})
    #   v_new = velocity(x_act,v_act,ex,ey,ez,bx,by,bz,-0.5*dt)
    #   # guarda en tiempo {n}
    #   output_particle(x_act,v_new,i)
    #   v_act = velocity(x_act,v_new,ex,ey,ez,bx,by,bz,0.5*dt)  #Para que adelantar v_act?
    #   bx,by,bz = FDTD_halftime(ex,ey,ez,bx,by,bz,-0.5*dt)
    #   output_fields(ex,ey,ez,bx,by,bz,jx,jy,jz,i)
    #   bx,by,bz = FDTD_halftime(ex,ey,ez,bx,by,bz,0.5*dt)

    # Nosotros

    if(i%n_out == 0): #Cada n_out iterations se guardan particle y campos
      #atrasa la velocidad para guardarla (la devuleve hasta tiempo {n})
      ex_copy, ey_copy, ez_copy, bx_copy, by_copy, bz_copy = interc_to_nodes(ex, ey, ez, bx, by, bz, ex_copy, ey_copy, ez_copy, bx_copy, by_copy, bz_copy)
      tmp_v_new = velocity(x_act,v_act,ex_copy, ey_copy, ez_copy, bx_copy, by_copy, bz_copy,-0.5*dt)
      output_particle(x_act, tmp_v_new, i) # guarda en tiempo {n}
      output_fields(ex_copy, ey_copy, ez_copy, bx_copy, by_copy, bz_copy,jx,jy,jz,i,divB)
      ex_tmp, ey_tmp, ez_tmp, bx_tmp, by_tmp, bz_tmp = interc_to_nodes(ex_copy, ey_copy, ez_copy, bx_copy,by_copy,bz_copy,ex_tmp, ey_tmp, ez_tmp, bx_tmp, by_tmp, bz_tmp)
      output_fields(ex_tmp,ey_tmp,ez_tmp,bx_tmp,by_tmp,bz_tmp,jx,jy,jz,i,divB,'fields_nodes')

df_energy.close()

i = 10

fig, ax = plt.subplots()
plt.title("Trayectoria de la partícula")
plt.xlabel("x")
plt.ylabel("y")
# Particle Trajectory
lp = []
lv = []
ii= 11 #particular N
print(ii)

for i in range(0,100,5):
  file_name = 'particle'+ str(i) +'.pkl'
  # print(file_name)
  df = pd.read_pickle(file_name)
  tmp1 = np.array(df.iloc[ii,[0,1,2]])
  tmp2 = np.array(df.iloc[ii,[3,4,5]])
  lp.append(tmp1)
  lv.append(tmp2)
lp = np.array(lp)
lv = np.array(lv)
for i in range(len(lp)):
  plt.plot(lp[i,0], lp[i,1],'bo')
  plt.plot()


i= 10 #iteration
file_name = 'particle'+ str(i) +'.pkl'
print(file_name)
df = pd.read_pickle(file_name)
x_act = np.array(df.iloc[:,[0,1,2]])
v_act = np.array(df.iloc[:,[3,4,5]])

v_new = velocity(x_act,v_act,ex,ey,ez,bx,by,bz,dt)
x_new,x_BC = position(x_act,v_new,x_new,x_BC)
jx,jy = zig_zag(x_act,x_new,x_BC,jx,jy,partweight)
jx
jy

plt.figure(13);plt.clf()

plt.subplot(1,2,1)
plt.rcParams['figure.figsize'] = [14, 6]
plt.rcParams['figure.dpi'] = 50 # 200 e.g. is really fine, but slower
plt.title("Densidad de corriente en x")
plt.xlabel("x")
plt.ylabel("y")
plt.imshow(jx[:,:],extent=[Xmin,Xmax,Ymin,Ymax],aspect='auto');plt.colorbar()

plt.subplot(1,2,2)
plt.title("Densidad de corriente en y")
plt.xlabel("x")
plt.ylabel("y")
plt.imshow(jy[:,:],extent=[Xmin,Xmax,Ymin,Ymax],aspect='auto');plt.colorbar()

fig.savefig('my_figure.png')

"""**texto en negrita**"""

df=

#INTENTO DE GRAFICAR CON ANIMACIÓN

fig = plt.figure()
ax = plt.axes(xlim=(0, Nx), ylim=(0, Ny))
line, = ax.plot([], [], lw=2)

lp = []
lv = []
ii= 11 #particular N


def init():
    line.set_data([], [])
    return line,


def animate(i):
    for ix in range(0,100,5):

      file_name = 'particle'+ str(ix) +'.pkl'
        # print(file_name)
      df = pd.read_pickle(file_name)
      tmp1 = np.array(df.iloc[ii,[0,1,2]])
      lp.append(tmp1)
    lp1 = np.array(lp)

    plt.plot(lp1[i,0], lp1[i,1])
    line.set_data(lp1[i,0], lp1[i,1])
    return line,


anim = animation.FuncAnimation(fig, animate, init_func=init,
                               frames=200, interval=20, blit=True)

anim.save('basic_animation.mp4', fps=30, extra_args=['-vcodec', 'libx264'])

plt.show()

import matplotlib as mpl
import matplotlib.pyplot as plt

plt.style.use('classic')

i = 0

import matplotlib.pyplot as plt
from matplotlib.colors import BoundaryNorm
from matplotlib.ticker import MaxNLocator

i=40
file_name = 'fields'+ str(i) +'.pkl'
df = pd.read_pickle(file_name)
print(file_name)
ex_tmp =  np.reshape(np.array(df['ex']),[Nx+1,Ny+1],order ='F')
ey_tmp =  np.reshape(np.array(df['ey']),[Nx+1,Ny+1], order ='F')
ez_tmp =  np.reshape(np.array(df['ez']),[Nx+1,Ny+1],order ='F')
bx_tmp =  np.reshape(np.array(df['bx']),[Nx+1,Ny+1],order ='F')
by_tmp =  np.reshape(np.array(df['by']),[Nx+1,Ny+1],order ='F')
bz_tmp =  np.reshape(np.array(df['bz']),[Nx+1,Ny+1],order ='F')
jx_tmp =  np.reshape(np.array(df['jx']),[Nx+1,Ny+1],order ='F')
jy_tmp =  np.reshape(np.array(df['jy']),[Nx+1,Ny+1],order ='F')
jz_tmp =  np.reshape(np.array(df['jz']),[Nx+1,Ny+1],order ='F')
divB_tmp = np.reshape(np.array(df['DivB']),[Nx+1,Ny+1],order ='F')


plt.figure(1);plt.clf()
plt.subplot(1,3,1)
plt.imshow(ex_tmp,extent=[Xmin,Xmax,Ymin,Ymax],aspect='auto', cmap='seismic');plt.colorbar()
plt.subplot(1,3,2)
plt.imshow(ey_tmp,extent=[Xmin,Xmax,Ymin,Ymax],aspect='auto', cmap='seismic');plt.colorbar()
plt.subplot(1,3,3)
plt.imshow(ez_tmp,extent=[Xmin,Xmax,Ymin,Ymax],aspect='auto', cmap='seismic');plt.colorbar()

plt.figure(2);plt.clf()
plt.subplot(1,3,1)
plt.imshow(bx_tmp,extent=[Xmin,Xmax,Ymin,Ymax],aspect='auto', cmap='seismic');plt.colorbar()
plt.subplot(1,3,2)
plt.imshow(by_tmp,extent=[Xmin,Xmax,Ymin,Ymax],aspect='auto', cmap='seismic');plt.colorbar()
plt.subplot(1,3,3)
plt.imshow(bz_tmp,extent=[Xmin,Xmax,Ymin,Ymax],aspect='auto', cmap='seismic');plt.colorbar()

plt.figure(4);plt.clf()
plt.subplot(1,3,1)
plt.imshow(jx_tmp,extent=[Xmin,Xmax,Ymin,Ymax],aspect='auto', cmap='seismic');plt.colorbar()
plt.subplot(1,3,2)
plt.imshow(jy_tmp,extent=[Xmin,Xmax,Ymin,Ymax],aspect='auto', cmap='seismic');plt.colorbar()
plt.subplot(1,3,3)
plt.imshow(jz_tmp,extent=[Xmin,Xmax,Ymin,Ymax],aspect='auto', cmap='seismic');plt.colorbar()

plt.figure();plt.clf()
plt.imshow(divB_tmp,aspect='auto',cmap='seismic');plt.colorbar()
print(np.sqrt(np.mean(divB_tmp**2)))
i=i+10;print(i)

objects = pd.read_pickle('fields25.pkl')
objects

"""**EJEMPLO Maxwell solver in two dimensions with FDTD scheme**"""

# Commented out IPython magic to ensure Python compatibility.
#EJEMPLO Maxwell solver in two dimensions with FDTD scheme


# %config InlineBackend.figure_format = 'retina'

import matplotlib.pyplot as plt
import numpy as np
from mpl_toolkits.mplot3d import axes3d
import matplotlib.animation as animation
from IPython.display import HTML

plt.rcParams['figure.figsize'] = (10,6)

# Mesh parameters
nx, ny = 101, 101
vx, dx = np.linspace(0, 1, nx, endpoint=True, retstep=True)
vy, dy = np.linspace(0, 1, ny, endpoint=True, retstep=True)

#Initialize Ex, Ey when time = 0
ex = np.zeros((nx-1, ny), dtype=np.double)
ey = np.zeros((nx, ny-1), dtype=np.double)
nbiter = 500   # time loop size
dt = 0.001     # time step
m, n = 2, 2
omega = np.sqrt((m*np.pi)**2+(n*np.pi)**2)
# Create the staggered grid for Bz
x, y = np.meshgrid(0.5*(vx[:-1]+vx[1:]), 0.5*(vy[:-1]+vy[1:]))

fig = plt.figure()
ax = axes3d.Axes3D(fig)

#Initialize Bz when time = - dt / 2
hz = - np.cos(m*np.pi*y) * np.cos(n*np.pi*x) * np.cos(omega*(-0.5*dt))
wframe = ax.plot_wireframe(x, y, hz, rstride=2, cstride=2)
ax.set_zlim(-1,1);

def faraday( ex, ey, hz ) :
    "faraday equation Bz(t+dt/2) -> Bz(t-dt/2) + dt f(E(t))"
    return hz + dt * ((ex[:, 1:]-ex[:, :-1]) / dy - (ey[1:, :]-ey[:-1, :]) / dx)

def ampere_maxwell( hz, ex, ey):
    " Ampere-Maxwell equation E(t+dt) -> E(t) + dt g(Bz(t+dt/2)) "
    ex[:, 1:-1] += dt*(hz[:, 1:]-hz[:, :-1]) / dy
    ey[1:-1, :] += - dt*(hz[1:, :]-hz[:-1, :]) / dx

    # periodic boundary conditions
    ex[:, 0] += dt*(hz[:, 0]-hz[:, -1]) / dy
    ex[:, -1] = ex[:, 0]
    ey[0, :] += - dt*(hz[0, :]-hz[-1, :]) / dx
    ey[-1, :] = ey[0, :]

    return ex, ey

def update(i, ax, fig):
    ax.cla()

    global ex, ey, hz

    for j in range(10):
        hz = faraday( ex, ey, hz)
        ex, ey = ampere_maxwell( hz, ex, ey)

    wframe = ax.plot_wireframe(x, y, hz, rstride=2, cstride=2)
    ax.set_zlim(-1, 1)
    return wframe,


ani = animation.FuncAnimation(fig, update,
                              frames=range(100),
                              fargs=(ax, fig), interval=20, blit=True)



HTML(ani.to_html5_video())